#  John Goettsche
#  under the direction of Clinton Jeffery
#  University of Idaho

package productionRules

import classes
import states

procedure createProductionRules(
         fileName,
         args,
         rawGrammar, 
         nonTerminalCheckSet, 
         nonTerminalsSet, 
         terminalCheckSet, 
         terminalsSet)
#  from the rawGrammar, nonTerminalCheckSet, nonTerminalSet,
#  terminalCheckSet and Terminals it produces the grammars and
#  stores them in their respective nonTerminal, then procedes to 
#  produce a report of the grammar

   local 
      grammar, 
      output,
      outfile,
      outfileName

	write("Creating Production Rules...\n")
   grammar := makeProductionRules(
         rawGrammar, 
         nonTerminalCheckSet, 
         nonTerminalsSet, 
         terminalCheckSet, 
         terminalsSet)

   #print tokens
   if *args > 0 then if member(args, "p") then {
      outfile := &output
      outfileName := fileName || "-productionRules.txt"
      if member(args, "o") then outfile := open(outfileName, "c")
      write("\nCreated a grammar with the following production rules:")
      if outfile ~=== &output then{
         every output := !nonTerminalsSet do {
            every write(outfile, output.getTxt())
         }
      }
      every output := !nonTerminalsSet do {
         every write("\t" || output.getTxt())
      }
		classes::printTime()
      write("\n(press ENTER to continue)\n")
      getch()
   }
   
   states::createStates(fileName, args, nonTerminalsSet, terminalsSet, terminalsSet)  
end

procedure makeProductionRules(
      rawGrammar, 
      nonTerminalCheckSet, 
      nonTerminalsSet, 
      terminalCheckSet, 
      terminalsList)
#  generates grammar rules from the rawGrammar, 
#  nonTerminalCheckSet, nonTerminalSet, terminalCheckSet
#  terminalsSet and populates each rule with the appropriate
#  terminal or nonTerminal

   local 
      x, 
      nonTerm, 
      nonTerminal,
      productionRule, 
      term
      
   x := 1
   while rawGrammar[x] do {   
      if member(nonTerminalCheckSet, rawGrammar[x]) then {#is a non terminal?
         if rawGrammar[x + 1] == ":" then { #is a grammar rule ?
            every nonTerm := !nonTerminalsSet do {
               if \nonTerm then {
                  if nonTerm.token == rawGrammar[x] then { 
                     nonTerminal := nonTerm
                     productionRule := classes::Production()
                     x := x + 1
                  }
               }
            }
         } else {
            every nonTerm := !nonTerminalsSet do {
               if \nonTerm then {
                  if nonTerm.token == rawGrammar[x] then {
                     productionRule.addVariable(nonTerm)
                  }
               }
            }
         }
      }#end non terminal

      #is a terminal?
      if member(terminalCheckSet, rawGrammar[x]) & rawGrammar[x] ~== "|" then {
         every term := !terminalsList do {
            if \term then {
               if term.token == rawGrammar[x] then productionRule.addVariable(term)
            }
         }
      }

      #is an or?
      if rawGrammar[x] == "|" then {
         nonTerminal.addProductionRule(productionRule)
         productionRule := classes::Production()
      }

      #is end of nonTerminal?
      if rawGrammar[x] == ";" then {
         nonTerminal.addProductionRule(productionRule)
         if rawGrammar[x + 1] == "|" then {
            productionRule := classes::ProductionRule()
            x +:= 1
         }
      }
      x +:= 1
   }
end