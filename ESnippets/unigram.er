procedure p(); 1 := 2 end 


::: missing semicolon or operator 
procedure main() 

every x do { } 

} 

end 


::: too many closing curly braces 
procedure main() 

y := X(1) 

z := a , b 

end 


::: missing semicolon or operator 
global 


::: unexpected end of file 
global x y 


::: invalid global declaration 
global x, , y 


::: missing identifier 
procedure p(x) end 


::: missing semicolon 
link procedure p(x) 

end 


::: link list expected 
invocable procedure p(x) 

end 


::: invocable list expected 
local x 


::: invalid declaration 
procedure main() 

a + 

end 


::: missing or invalid second argument to + 
procedure main() 

a * 

end 


::: missing or invalid second argument to * 
procedure main() 

a ! 

end 


::: missing or invalid second argument to ! 
procedure () 

end 


::: procedure name expected 
procedure p(1) 

end 


::: parameter name expected 
procedure p(x,) 

end 


::: parameter name expected 
procedure p(x) 

global x 

end 


::: semicolon expected 
procedure p(x); 

global x 

end 


::: invalid procedure body 
procedure p() 

! 

end 


::: invalid argument to unary ! 
procedure p() 

c$m || x 

end 


::: parenthesis is required for method invocation 
procedure p() 

create 

end 


::: invalid create expression 
procedure p() 

{ 

end 


::: invalid compound expression 
procedure main() 

{ := 3 

end 


::: assignment missing its left operand 
procedure p() 

if 

end 


::: invalid if control expression 
procedure p() 

case 

end 


::: invalid case control expression 
procedure p() 

while 

end 


::: invalid while control expression 
procedure p() 

until 

end 


::: invalid until control expression 
procedure p() 

every 

end 


::: invalid every control expression 
procedure p() 

repeat 

end 


::: invalid repeat control expression 
link x+ 

procedure p() 

end 


::: invalid link declaration 
procedure p 

write() 

end 


::: missing parameter list in procedure declaration 
procedure p() 

local hello 

end 


::: invalid local declaration 
class c() 

[ 

end 


::: method expected 
class c() 

method m(); [ 

end 


::: unclosed list 
class c() 

method m(); [ help! 

end 


::: unclosed list 
class c() 

method m(); [ help! end 

end 


::: missing operator or closing bracket 
class c() 

method m();end 

procedure p();end 

end 


::: procedure not allowed within a class 
class c() 

procedure p();end 

end 


::: procedure not allowed within a class 
procedure p() 

initial ] 

end 


::: invalid initial expression 
procedure p() 

if (1) { 

hello 

} 

end 


::: missing then 
procedure p() 

if 1) { 

hello 

} 

end 


::: spurious close-parenthesis 
procedure p() 

write(p() 

hello 

end 


::: unclosed parenthesis 
procedure main(); { 

| x) 

} 

end 


::: missing operator or unbalanced parenthesis/bracket 
procedure p() 

if a.b | ( a.b & c(e) == t then { 

end 


::: unclosed parenthesis 
procedure p() 

a$b(c[3] 

{ 

end 


::: unclosed parenthesis 
procedure main() 

case x of { 

y: 

f(); g() 

} 

end 


::: malformed case expression 
procedure main() 

case x of { 

case y: 

f() 

} 

end 


::: missing of in case expression 
procedure main() 

while x do { x 

end 


::: missing } somewhere before end 
procedure p() 

initial { 

if foo then { 

} 

end 


::: an initial clause is missing } somewhere before end 
procedure dbdelete(db, filter) 

sql(db, DELETE FROM || blah blah || filter) 

end 


::: unclosed literal or missing operator 
procedure p() 

s || +:= k 

end 


::: missing operand after || 
procedure p() 

s || := k 

end 


::: illegal space inside ||:= 
procedure p() 

s ||| +:= k 

end 


::: missing operand after ||| 
procedure p() 

s ||| := k 

end 


::: illegal space inside |||:= 
class c() method m(); if x + &1press then p() 


::: bad keyword name or bogus & precedes this token 
class c() method m() if 


::: a ; or n is missing between method header and body 
procedure main() 

l. := foo 

end 


::: field name expected 
procedure p(x:[ list ]); end 


::: parameter modifier must be a (atomic) literal or a convertor 
class A() 

method m() 

write() 

local g 

end 

end 


::: expression expected, or need to move declaration to top of procedure or method 
class C x ) 

end 


::: left parenthesis expected to start class fieldlist 
class C { x ) 

end 


::: fieldlist starts with left *parenthesis*, not curly brace! 
procedure main() 

while ((str:=reads(f4,100))) { 

write(s) 

writes(x) 

} 

end 


::: missing do or some such keyword earlier, or expected a comma or right brace here 
procedure move_characters() 

every u do { 

if x then 

} 

end 


::: missing then-part 
class C(X Y) 


::: missing comma or unclosed class field arguments 
class C( 

# hmmm!!!) 



method check_mobile() 

end 

end 


::: missing fieldname or right parenthesis 
class C(foo 

# hmmm!!!) 



method check_mobile() 

end 

end 


::: unclosed class field arguments 
procedure main(); every read() write(); end 


::: missing operator or do keyword 
class A(); end + 


::: global, class, or link expected 
class A(); end method 


::: method declaration outside any class 
class threaddata(id,); end 


::: missing field name 
initially 

#EOFX initially 

; 

record x ( ) initially 

procedure x ( ) ; end initially 

global x initially 

link x initially 

package x initially 

import x initially 

invocable x initially 

class x ( ) ; end initially 

procedure x ( ) initially 

class x ( ) initially 

procedure x ( ) ; initially 

class x ( ) ; initially 

global x , initially 

link x , initially 

import x , initially 

invocable x , initially 

class x initially 

record x ( initially 

record x ( x initially 

procedure x ( ) ; initial initially 

procedure x ( ) ; local initially 

procedure x ( ) ; static initially 

procedure x ( initially 

procedure x ( x initially 

global x , x initially 

link x , x initially 

import x , x initially 

invocable x , x initially 

class x ( ) abstract method x ( ) initially 

class x ( ) global x initially 

class x ( ) record x ( ) initially 

class x ( ) method x ( ) initially 

class x ( ) abstract initially 

class x ( ) method initially 

class x ( ) local initially 

class x ( initially 

class x : :: x initially 

procedure x ( ) ; 0 initially 

procedure x ( ) ; 0 @> initially 

procedure x ( ) ; @ initially 

procedure x ( ) ; @> initially 

procedure x ( ) ; @>> initially 

procedure x ( ) ; <@ initially 

procedure x ( ) ; <<@ initially 

procedure x ( ) ; not initially 

procedure x ( ) ; | initially 

procedure x ( ) ; || initially 

procedure x ( ) ; ||| initially 

procedure x ( ) ; . initially 

procedure x ( ) ; ! initially 

procedure x ( ) ; -- initially 

procedure x ( ) ; + initially 

procedure x ( ) ; * initially 

procedure x ( ) ; / initially 

procedure x ( ) ; % initially 

procedure x ( ) ; ** initially 

procedure x ( ) ; ~ initially 

procedure x ( ) ; - initially 

procedure x ( ) ; -> initially 

procedure x ( ) ; ++ initially 

procedure x ( ) ; .$ initially 

procedure x ( ) ; 0 { 0 : 0 } initially 

procedure x ( ) ; fail initially 

procedure x ( ) ; if 0 then 0 initially 

procedure x ( ) ; case 0 of [ default : 0 ] initially 

procedure x ( ) ; while 0 initially 

procedure x ( ) ; until 0 initially 

procedure x ( ) ; every 0 initially 

procedure x ( ) ; repeat 0 initially 

procedure x ( ) ; ` initially 

procedure x ( ) ; create initially 

procedure x ( ) ; thread initially 

procedure x ( ) ; critical initially 

procedure x ( ) ; x initially 

procedure x ( ) ; next initially 

procedure x ( ) ; break initially 

procedure x ( ) ; ( initially 

procedure x ( ) ; [ initially 

procedure x ( ) ; { initially 

procedure x ( ) ; :: x initially 

procedure x ( ) ; & initially 

procedure x ( ) ; 1.0 initially 

procedure x ( ) ; a initially 

procedure x ( ) ; c initially 

procedure x ( ) ; return initially 

procedure x ( ) ; suspend initially 

procedure x ( ) ; if initially 

procedure x ( ) ; case initially 

procedure x ( ) ; while initially 

procedure x ( ) ; until initially 

procedure x ( ) ; every initially 

procedure x ( ) ; repeat initially 

procedure x ( ) ; initial 0 initially 

procedure x ( ) ; local x initially 

procedure x ( ) ; static x initially 

procedure x ( x { initially 

procedure x ( x , initially 

class x ( ) ; 

class x ( ) method x ( ) ; initially 

class x ( ) method x initially 

class x ( ) local x initially 

class x ( x initially 

class x ( + initially 

class x ( - initially 

class x : x initially 

procedure x ( ) ; ; initially 

procedure x ( ) ; 0 & initially 

procedure x ( ) ; 0 initial initially 

procedure x ( ) ; 0 : initially 

procedure x ( ) ; 0 assign initially 

procedure x ( ) ; 0 <-> initially 

procedure x ( ) ; 0 <- initially 

procedure x ( ) ; 0 ||: initially 

procedure x ( ) ; 0 |||: initially 

procedure x ( ) ; 0 --: initially 

procedure x ( ) ; 0 ++: initially 

procedure x ( ) ; 0 +: initially 

procedure x ( ) ; 0 -: initially 

procedure x ( ) ; 0 *: initially 

procedure x ( ) ; 0 **: initially 

procedure x ( ) ; 0 /: initially 

procedure x ( ) ; 0 %: initially 

procedure x ( ) ; 0 > initially 

procedure x ( ) ; 0 >: initially 

procedure x ( ) ; 0 < initially 

procedure x ( ) ; 0 <: initially 

procedure x ( ) ; 0 ~ initially 

procedure x ( ) ; 0 >> initially 

procedure x ( ) ; 0 >>: initially 

procedure x ( ) ; 0 << initially 

procedure x ( ) ; 0 <<: initially 

procedure x ( ) ; 0 &: initially 

procedure x ( ) ; 0 @: initially 

procedure x ( ) ; 0 to initially 

procedure x ( ) ; 0 .| initially 

procedure x ( ) ; 0 && initially 

procedure x ( ) ; 0 | initially 

procedure x ( ) ; 0 $$ initially 

procedure x ( ) ; 0 -> initially 

procedure x ( ) ; 0 || initially 

procedure x ( ) ; 0 ||| initially 

procedure x ( ) ; 0 + initially 

procedure x ( ) ; 0 -- initially 

procedure x ( ) ; 0 ++ initially 

procedure x ( ) ; 0 - initially 

procedure x ( ) ; 0 * initially 

procedure x ( ) ; 0 ** initially 

procedure x ( ) ; 0 / initially 

procedure x ( ) ; 0 % initially 

procedure x ( ) ; 0 <<@ initially 

procedure x ( ) ; 0 @ initially 

procedure x ( ) ; 0 @>> initially 

procedure x ( ) ; 0 <@ initially 

procedure x ( ) ; 0 ! initially 

procedure x ( ) ; 0 { initially 

procedure x ( ) ; 0 [ initially 

procedure x ( ) ; 0 ( initially 

procedure x ( ) ; 0 $ ; 

procedure x ( ) ; 0 . ; 

procedure x ( ) ; @ 0 initially 

procedure x ( ) ; @> 0 initially 

procedure x ( ) ; @>> 0 initially 

procedure x ( ) ; <@ 0 initially 

procedure x ( ) ; <<@ 0 initially 

procedure x ( ) ; not 0 initially 

procedure x ( ) ; | 0 initially 

procedure x ( ) ; || 0 initially 

procedure x ( ) ; ||| 0 initially 

procedure x ( ) ; . 0 initially 

procedure x ( ) ; ! 0 initially 

procedure x ( ) ; -- 0 initially 

procedure x ( ) ; + 0 initially 

procedure x ( ) ; * 0 initially 

procedure x ( ) ; / 0 initially 

procedure x ( ) ; % 0 initially 

procedure x ( ) ; ** 0 initially 

procedure x ( ) ; ~ 0 initially 

procedure x ( ) ; - 0 initially 

procedure x ( ) ; -> 0 initially 

procedure x ( ) ; ++ 0 initially 

procedure x ( ) ; .$ 0 initially 

procedure x ( ) ; create 0 initially 

procedure x ( ) ; thread 0 initially 

procedure x ( ) ; critical 0 initially 

procedure x ( ) ; { default : 0 initially 

procedure x ( ) ; { default initially 

procedure x ( ) ; { 0 initially 

procedure x ( ) ; { : initially 

procedure x ( ) ; & fail initially 

procedure x ( ) ; & x initially 

procedure x ( ) ; if 0 initially 

procedure x ( ) ; case 0 initially 

procedure x ( ) ; initial 0 ; initially 

procedure x ( ) ; local x ; initially 

procedure x ( ) ; local x , initially 

procedure x ( ) ; local x assign initially 

procedure x ( ) ; static x ; initially 

procedure x ( ) ; static x , initially 

procedure x ( ) ; static x assign initially 

procedure x ( x { } initially 

procedure x ( x , x initially 

procedure x ( x : 0 initially 

class x ( ) initially initially 

class x ( ) method x ( initially 

class x ( x { initially 

class x ( x , initially 

procedure x ( ) ; 0 & 0 initially 

procedure x ( ) ; 0 initial 0 initially 

procedure x ( ) ; 0 : 0 initially 

procedure x ( ) ; 0 assign 0 initially 

procedure x ( ) ; 0 <-> 0 initially 

procedure x ( ) ; 0 <- 0 initially 

procedure x ( ) ; 0 ||: 0 initially 

procedure x ( ) ; 0 |||: 0 initially 

procedure x ( ) ; 0 --: 0 initially 

procedure x ( ) ; 0 ++: 0 initially 

procedure x ( ) ; 0 +: 0 initially 

procedure x ( ) ; 0 -: 0 initially 

procedure x ( ) ; 0 *: 0 initially 

procedure x ( ) ; 0 **: 0 initially 

procedure x ( ) ; 0 /: 0 initially 

procedure x ( ) ; 0 %: 0 initially 

procedure x ( ) ; 0 > 0 initially 

procedure x ( ) ; 0 >: 0 initially 

procedure x ( ) ; 0 < 0 initially 

procedure x ( ) ; 0 <: 0 initially 

procedure x ( ) ; 0 ~ 0 initially 

procedure x ( ) ; 0 >> 0 initially 

procedure x ( ) ; 0 >>: 0 initially 

procedure x ( ) ; 0 << 0 initially 

procedure x ( ) ; 0 <<: 0 initially 

procedure x ( ) ; 0 &: 0 initially 

procedure x ( ) ; 0 @: 0 initially 

procedure x ( ) ; 0 to 0 initially 

procedure x ( ) ; 0 .| 0 initially 

procedure x ( ) ; 0 && 0 initially 

procedure x ( ) ; 0 | 0 initially 

procedure x ( ) ; 0 $$ 0 initially 

procedure x ( ) ; 0 -> 0 initially 

procedure x ( ) ; 0 || 0 initially 

procedure x ( ) ; 0 ||| 0 initially 

procedure x ( ) ; 0 + 0 initially 

procedure x ( ) ; 0 -- 0 initially 

procedure x ( ) ; 0 ++ 0 initially 

procedure x ( ) ; 0 - 0 initially 

procedure x ( ) ; 0 * 0 initially 

procedure x ( ) ; 0 ** 0 initially 

procedure x ( ) ; 0 / 0 initially 

procedure x ( ) ; 0 % 0 initially 

procedure x ( ) ; 0 <<@ 0 initially 

procedure x ( ) ; 0 @ 0 initially 

procedure x ( ) ; 0 @> 0 initially 

procedure x ( ) ; 0 @>> 0 initially 

procedure x ( ) ; 0 <@ 0 initially 

procedure x ( ) ; 0 ! 0 initially 

procedure x ( ) ; 0 [ ] initially 

procedure x ( ) ; 0 $ initially initially 

procedure x ( ) ; 0 $ x initially 

procedure x ( ) ; 0 . x initially 

procedure x ( ) ; 0 . initially initially 

procedure x ( ) ; critical 0 : initially 

procedure x ( ) ; ( ) initially 

procedure x ( ) ; ( , initially 

procedure x ( ) ; [ ] initially 

procedure x ( ) ; [ ; initially 

procedure x ( ) ; { default : 0 } initially 

procedure x ( ) ; { default : 0 ; initially 

procedure x ( ) ; { default : initially 

procedure x ( ) ; { 0 : initially 

procedure x ( ) ; { } initially 

procedure x ( ) ; { : 0 initially 

procedure x ( ) ; suspend do initially 

procedure x ( ) ; if 0 then initially 

procedure x ( ) ; case 0 of initially 

procedure x ( ) ; while 0 do initially 

procedure x ( ) ; until 0 do initially 

procedure x ( ) ; every 0 do initially 

procedure x ( ) ; local x , x initially 

procedure x ( ) ; local x assign 0 initially 

procedure x ( ) ; static x , x initially 

procedure x ( ) ; static x assign 0 initially 

class x ( ) end initially 

class x ( ) initially ; initially 

class x ( ) initially ( initially 

class x ( x { } initially 

class x ( x , x initially 

procedure x ( ) ; 0 to 0 by initially 

procedure x ( ) ; 0 { } initially 

procedure x ( ) ; 0 { : initially 

procedure x ( ) ; 0 { +: initially 

procedure x ( ) ; 0 { -: initially 

procedure x ( ) ; 0 [ , initially 

procedure x ( ) ; 0 ( ) initially 

procedure x ( ) ; 0 $ initially ( initially 

procedure x ( ) ; 0 $ x ( initially 

procedure x ( ) ; 0 $ x . ; 

procedure x ( ) ; critical 0 : 0 initially 

procedure x ( ) ; { default : 0 ; default : 0 initially 

procedure x ( ) ; { 0 : 0 initially 

procedure x ( ) ; { : 0 : initially 

procedure x ( ) ; suspend do 0 initially 

procedure x ( ) ; case 0 of [ initially 

procedure x ( ) ; while 0 do 0 initially 

procedure x ( ) ; until 0 do 0 initially 

procedure x ( ) ; every 0 do 0 initially 

procedure x ( ) ; local x , x assign initially 

procedure x ( ) ; static x , x assign initially 

procedure x ( x : x : 0 initially 

procedure x ( ) ; 0 to 0 by 0 initially 

procedure x ( ) ; 0 { : 0 initially 

procedure x ( ) ; 0 $ x . initially initially 

procedure x ( ) ; 0 $ x . x initially 

procedure x ( ) ; { : 0 : } initially 

procedure x ( ) ; if 0 then 0 else initially 

procedure x ( ) ; case 0 of [ default : 0 initially 

procedure x ( ) ; local x , x assign 0 initially 

procedure x ( ) ; static x , x assign 0 initially 

class x ( ) initially ( ) initially 

class x ( ) method x ( ) ; end initially 

procedure x ( ) ; 0 { : 0 } initially 

procedure x ( ) ; 0 $ initially ( ) initially 

procedure x ( ) ; 0 $ x ( ) initially 

procedure x ( ) ; 0 $ x . initially ( initially 

procedure x ( ) ; 0 $ x . x ( initially 

procedure x ( ) ; if 0 then 0 else 0 initially 

class x ( ) initially ( ) ; initially 

procedure x ( ) ; 0 $ x . initially ( ) initially 

procedure x ( ) ; 0 $ x . x ( ) initially 

