#  John Goettsche
#  under the direction of Clinton Jeffery
#  University of Idaho

package states
import rawGrammar
import production

procedure createStates(args, nonTerminalsSet, TerminalsSet)
#  is a work in progress
#  creates the states for compiling the Item for this tool

   local 
      statesList, 
      thisNonTerminal, 
      myState, 
      thisProductionRule, 
      myItem, 
      B,
      nextProductionRule,
      mySubItem,
      state,
      stateNumbnier,
      ItemList,
      outfile,
      thisResult

   #write("N: " || *nonTerminalsSet || "\tT: " || *TerminalsSet)
   stateNumber := 0
   statesList := []
   itemSet := set()
   
   #make item 0
   thisNonTerminal := nonTerminalsSet[1]
   stateName := "I" || stateNumber
   thisResult := thisNonTerminal.getResult() || "'"
   thisPrime := rawGrammar::Terminal(2)
   thisPrime.setResult(thisResult)
   initialItem := Item()
   initialItem.addBeta(thisNonTerminal)
   myState := State(stateName, thisPrime, initialItem) #create new state
   
   every thisItem := myState.getItems() do {
      B := thisItem.getBeta(1)
      if B.getType() == "1" then {
         if not member(itemSet, B) then {
            makeItems(myState, B, itemSet)
            insert(itemSet, B)
         }
      }
   }
   put(statesList, myState)
   
   makeAllStates(statesList, myState)
   
   if *args > 0 then if member(args, "s") then {
      outfile := &output
      if member(args, "o") then outfile := open("y-states.txt", "c")
      write("\nStates: " || *statesList || "\n") 
      if outfile ~=== &output then every state := !statesList do write(outfile, state.getTxt())
      every state := !statesList do write(state.getTxt())
      write("\n(press ENTER to continue)\n")
      getch()
   }   
end
   
procedure makeItems(myState, B, itemSet)
# Makes Items for myState given a Non-Terminal (B)

   local
      mySubItem,
      newProductionRule,
      newVariable,
      stateNumber,
      stateName   
    
   every thisProductionRule := B.getProductionRules() do {
      newItem := Item()
      newItem.setLeft(B)
      every newB := thisProductionRule.getVariables() do{
         newItem.addBeta(newB)
      }
      if not duplicateItem(myState.getItemsList(), newItem) then {
         myState.addItem(newItem)
      }
   }
   
   every thisProductionRule := B.getProductionRules() do {
      newB := thisProductionRule.getVariable(1)
      if newB.getType() == "1" then {
         if not member(itemSet, newB) then { 
				insert(itemSet, newB)
            makeItems(myState, newB, itemSet)
         }
      }
   }
end

procedure makeAllStates(statesList, state)
   local 
      stateNumber, 
      thisState,
      newState,
      thisResult,
      newItem,
      ItemList,
      shifts,
      count
   
   stateNumber := 0   
   count := 1
   while stateNumber = 0 | count < stateNumber do {
      write(count - 1 || " / I" || stateNumber)
      if stateNumber = 0 then thisState := state
      if stateNumber > 0 then thisState := statesList[count]
      count +:= 1   
      shifts := []
      every thisItem := thisState.getItems() do {
         newItem := thisItem.getShift()
         shiftElement := newItem.getLastAlpha()
         put(shifts, shiftElement)
         element := newItem.getLeft()
         if element.getType() == ("1" | "2") then {
            if not member(shifts, element) then {
               ItemList := []
               stateNumber +:= 1
               stateName := "I" || stateNumber
               newState := State(stateName, element, newItem)
               makeAllItems(statesList, thisState, newState, shiftElement)
               if duplicateState(statesList, newState) then {
                  stateNumber -:= 1
               } else {
						if not duplicateState(statesList, newState) then {
							put(statesList, newState)
						}
					}
            }
         }
      }
   }
end

procedure makeAllItems(statesList, oldState, thisState, shiftElement)
   local 
      newItem,
      thisItem,
      itemSet
      
   itemSet := set()
   every thisItem := oldState.getItems() do {
      newItem := thisItem.getShift()
		if \newItem then {
			if not duplicateStateLabel(statesList, newItem) then {
				if newItem.getLastAlpha() === shiftElement then {
					if not duplicateItem(thisState.getItemsList(), newItem) then {
						thisState.addItem(newItem)
					}
					B := newItem.getBeta(1)
					if \B then if B.getType() = "1" then
						makeItems(thisState, B, itemSet)
				}
			}
		}
	}
end

procedure duplicateItem(itemList, item)
#  checks to see if Item is in the ItemList, if it is
#  the Item is suspended

   local thisItem
   every thisItem := !itemList do {
      if thisItem.getTxt() == item.getTxt() then {
         suspend item
      }
   }
end

procedure duplicateState(statesList, state)
#  Checks to see if the state is a duplicate by checking
#  the first production in the state with the first
#  production of all the states in the stateList

   local 
      thisState,
      thisItem
      
   items := state.getItemsList()
   item := items[1]
   every testState := !statesList do {
      testItems := testState.getItemsList()
      every testItem := !testItems do  
			if testItem.getTxt() == item.getTxt() then return state
   }
end

procedure duplicateStateLabel(statesList, thisLabel)
	every thisState := !statesList do {
		labelsList := thisState.getItemsList()
		if thisLabel.getTxt() == labelsList[1].getTxt() then return thisLabel
	}
end

class State(name, items)
#  this class defines a state for compiling the Item

   method setName(newName)
      name := newName
   end

   method addItem(itemProduction)
      put(items, itemProduction)
   end
   
   method addAlpha(newAlpha, ItemNumber)
      Items[ItemNumber].addAlpha(newAlpha)
   end

   method getName()
      return name
   end

   method getItems()
      local itemProduction
      every itemProduction := !items do suspend itemProduction
   end

   method getItemsList()
      return items
   end

   method getTxt()
      local txt, line
      txt := name || "\n"
      every line := !items do txt := txt || line.getTxt()
      return txt
   end

initially(newName, thisPrime, initialItem)
   local 
      result,
      element

   name := newName
   items := []
   newItem := Item()
   newItem.setLeft(thisPrime)
   every newAlpha := initialItem.getAlpha() do {
      newItem.addAlpha(newAlpha)
   }
   every element := initialItem.getBetas() do
      newItem.addBeta(element)
   put(items, newItem)
end

class Item(left, alpha, beta)
#  this class defines a a Item process for the current state

   method setLeft(newLeft)
      #write(newLeft.getResult())
      left := newLeft
   end
   
   method addAlpha(newAlpha)
   #write("adding: " || newAlpha.getResult())
      put(alpha, newAlpha)
   end
   
   method addBeta(newBeta)
     # write(newItemElement.getTxt())
         put(beta, newBeta)
   end
   
   method setBetaList(newBetaList)
      beta := newBetaList
   end
   
   method getLeft()
      return left
   end
   
   method getAlpha()
      local element
      every element := !alpha do suspend element
   end
   
   method getAlphaList()
      return alpha
   end
   
   method getLastAlpha()
      local element, thisElement
      #write("getting shift")
      #write("+ " || *getAlphaList())
      every thisElement := getAlpha() do {
         #write("+" || thisElement.getResult())
         element := thisElement
      }
      #write(element.getResult())
      return element
   end
   
   method getBetas()
      local thisBeta
      every thisBeta := !beta do suspend thisBeta
   end
   
   method getBetaList()
      return beta
   end
   
   method getBeta(v)
      return beta[v]
   end
   
   method getShift()
      local newItem, element, count
      
      if *beta > 0 then {
         newItem := Item()
         newItem.setLeft(left)
         every element := getAlpha() do newItem.addAlpha(element)
         count := 1
         every element := getBetas() do {
            if count = 1 then {
               newItem.addAlpha(element)
            }   
            if count > 1 then {
               newItem.addBeta(element)
            }
            count +:= 1
         }
         return newItem
      }   
   end
   
   method getTxt()
      local txt, p, g, element
      txt := "\t" || left.getResult() || " -> "
      p := 1
      while p <= *alpha do {
         txt := txt || " " || alpha[p].getResult()
         p +:= 1
      }      
      txt := txt || "."
      g := 1
      while g <= *beta do {
         element := beta[g]
         if \element then txt := txt || element.getResult() || " "
         g +:= 1
      }
      txt := txt || "\n"
      return txt
   end
   
initially()
   alpha := []
   beta := []
end
