#  John Goettsche
#  under the direction of Clinton Jeffery
#  University of Idaho

package states
import grammars
import productionRules

procedure createStates(fileName, args, nonTerminalsSet, TerminalsSet)
#  is a work in progress
#  creates the states for compiling the Item for this tool

   local 
      statesList, 
      thisNonTerminal, 
      myState, 
      thisProductionRule, 
      myItem, 
      B,
      nextProductionRule,
      mySubItem,
      state,
      stateNumber,
      ItemList,
      outfile,
      thisResult,
      itemSet,
      stateName,
      thisPrime,
      initialItem,
      thisItem,
      outfileName,
      time,
      h,
      m,
      seconds

   #write("N: " || *nonTerminalsSet || "\tT: " || *TerminalsSet)
   stateNumber := 0
   statesList := []
   itemSet := set()
   
   #make item 0
   thisNonTerminal := nonTerminalsSet[1]
   stateName := "I" || stateNumber
   thisResult := thisNonTerminal.getResult() || "'"
   thisPrime := grammars::Terminal(2)
   thisPrime.setResult(thisResult)
   initialItem := Item()
   initialItem.addBeta(thisNonTerminal)
   myState := State(stateName, thisPrime, initialItem) #create new state
   
   every thisItem := myState.getItems() do {
      B := thisItem.getBeta(1)
      if B.getType() == "1" then {
         if not member(itemSet, B) then {
            makeItems(myState, B, itemSet)
            insert(itemSet, B)
         }
      }
   }
   myState.setTxt()
   put(statesList, myState)
   
   makeAllStates(statesList, myState)
   
   if *args > 0 then if member(args, "s") then {
      outfile := &output
      outfileName := fileName || "-states.txt"
      if member(args, "o") then outfile := open(outfileName, "c")
      write("\nStates: " || *statesList || "\n") 
      if outfile ~=== &output then every state := !statesList do write(outfile, state.getTxt())
      every state := !statesList do write(state.getTxt())
      time := &time
      h := time / 3600000
      time := time % 3600000
      m := time / 60000
      time := time % 60000
      seconds := time / 1000.0
      write("\nTime elapsed: " || h || ":" || m || ":" || seconds)
      write("\n(press ENTER to continue)\n")
      getch()
   }   
end
   
procedure makeItems(myState, B, itemSet)
# Makes Items for myState given a Non-Terminal (B)

   local
      mySubItem,
      newProductionRule,
      newVariable,
      stateNumber,
      stateName,
      thisProductionRule,
      newItem,
      newB
    
   every thisProductionRule := B.getProductionRules() do {
      newItem := Item()
      newItem.setLeft(B)
      every newB := thisProductionRule.getVariables() do{
         newItem.addBeta(newB)
      }
      newItem.setTxt()
      if not duplicateItem(myState.getItemsList(), newItem) then {
         myState.addItem(newItem)
      }
   }
   
   every thisProductionRule := B.getProductionRules() do {
      newB := thisProductionRule.getVariable(1)
      if newB.getType() == "1" then {
         if not member(itemSet, newB) then { 
				insert(itemSet, newB)
            makeItems(myState, newB, itemSet)
         }
      }
   }
end

procedure makeAllStates(statesList, state)
# generates all states or goto operations as described in
# pages 224 through 227 of the Dragon Book

   local 
      stateNumber, 
      thisState,
      newState,
      thisResult,
      newItem,
      ItemList,
      shifts,
      count,
      thisItem,
      shiftElement,
      element,
      stateName
   
   stateNumber := 0   
   count := 1
   while stateNumber = 0 | count < stateNumber do {
      write(count - 1 || " / I" || stateNumber)
      if stateNumber = 0 then thisState := state
      if stateNumber > 0 then thisState := statesList[count]
      count +:= 1   
      shifts := [] 
      #shifts are the most recent element shifted over in an
      #item or the most recent alpha element
      every thisItem := thisState.getItems() do {
         newItem := thisItem.getShift() 
         #newItem.setTxt()
         #moves the current location to the right one element
         #in the item
         shiftElement := newItem.getLastAlpha()
         put(shifts, shiftElement)
         element := newItem.getLeft()
         if element.getType() == ("1" | "2") then {
         #checks to see if the element is a non-terminal or a prime
            if not member(shifts, element) then {
               ItemList := []
               stateNumber +:= 1
               stateName := "I" || stateNumber
               newState := State(stateName, element, newItem)
               makeAllItems(statesList, thisState, newState, shiftElement)
               if duplicateState(statesList, newState) then {
                  stateNumber -:= 1
               } else {
						if not duplicateState(statesList, newState) then {
                     newState.setTxt()
							put(statesList, newState)
						}
					}
            }
         }
      }
   }
end

procedure makeAllItems(statesList, oldState, thisState, shiftElement)
# makes all remaining items for the state by implementing the closure function
# as depicted in Figure 4.33 of the Dragon Book
   local 
      newItem,
      thisItem,
      itemSet,
      B
      
   itemSet := set()
   every thisItem := oldState.getItems() do {
      newItem := thisItem.getShift()
		if \newItem then {
         newItem.setTxt()
			if not duplicateStateLabel(statesList, newItem) then {
				if newItem.getLastAlpha() === shiftElement then {
					if not duplicateItem(thisState.getItemsList(), newItem) then {
						thisState.addItem(newItem)
					}
					B := newItem.getBeta(1)
					if \B then if B.getType() = "1" then
						makeItems(thisState, B, itemSet)
				}
			}
		}
	}
end

procedure duplicateItem(itemList, item)
#  checks to see if Item is in the ItemList, if it is
#  the Item is suspended

   local 
      thisItem      
 
   every thisItem := !itemList do {
      if thisItem.label == item.label then {
         suspend item
      }
   }
end

procedure duplicateState(statesList, state)
#  Checks to see if the state is a duplicate by checking
#  the first production in the state with the first
#  production of all the states in the stateList

   local 
      items,
      item,
      testItem,
      testItems,
      testState      
      
   items := state.getItemsList()
   item := items[1]
   every testState := !statesList do {
      testItems := testState.getItemsList()
      every testItem := !testItems do  
			if testItem.label == item.label then return state
   }
end

procedure duplicateStateLabel(statesList, thisLabel)
   local
      thisState,
      labelsList
      
	every thisState := !statesList do {
		labelsList := thisState.getItemsList()
		if thisLabel.label == labelsList[1].label then return thisLabel
	}
end

class State(name, items, label)
#  this class defines a state

   method setName(newName)
      name := newName
   end

   method addItem(itemProduction)
      put(items, itemProduction)
   end
   
   method addAlpha(newAlpha, ItemNumber)
      items[ItemNumber].addAlpha(newAlpha)
   end

   method getName()
      return name
   end

   method getItems()
      local itemProduction
      every itemProduction := !items do suspend itemProduction
   end

   method getItemsList()
      return items
   end

   method setTxt()
      local txt, line
      txt := name || "\n"
      every line := !items do txt := txt || line.label
      label := txt
   end
   
   method getTxt()
      return label
   end

initially(newName, thisPrime, initialItem)
   local 
      result,
      element,
      newItem,
      newAlpha
   
   label :=""
   name := newName
   items := []
   
   #set up initialItem
   newItem := Item()
   newItem.setLeft(thisPrime)
   every newAlpha := initialItem.getAlpha() do {
      newItem.addAlpha(newAlpha)
   }
   every element := initialItem.getBetas() do
      newItem.addBeta(element)
   newItem.setTxt()
   put(items, newItem)
   setTxt()
end

class Item(left, alpha, beta, label)
#  this class defines an Item for a state

   method setLeft(newLeft)
      left := newLeft
   end
   
   method addAlpha(newAlpha)
      put(alpha, newAlpha)
   end
   
   method addBeta(newBeta)
         put(beta, newBeta)
   end
   
   method setBetaList(newBetaList)
      beta := newBetaList
   end
   
   method getLeft()
      return left
   end
   
   method getAlpha()
      local element
      every element := !alpha do suspend element
   end
   
   method getAlphaList()
      return alpha
   end
   
   method getLastAlpha()
      local element, thisElement
      every thisElement := getAlpha() do {
         element := thisElement
      }
      return element
   end
   
   method getBetas()
      local thisBeta
      every thisBeta := !beta do suspend thisBeta
   end
   
   method getBetaList()
      return beta
   end
   
   method getBeta(v)
      return beta[v]
   end
   
   method getShift()
      local 
         newItem, 
         element, 
         count
      
      if *beta > 0 then {
         newItem := Item()
         newItem.setLeft(left)
         every element := getAlpha() do newItem.addAlpha(element)
         count := 1
         every element := getBetas() do {
            if count = 1 then {
               newItem.addAlpha(element)
            }   
            if count > 1 then {
               newItem.addBeta(element)
            }
            count +:= 1
         }
         newItem.setTxt()
         return newItem
      }   
   end
   
   method setTxt()
   #prepares the textual representation of the Item
      local 
         p, 
         g, 
         element,
         txt
         
      txt := "\t" || left.getResult() || " -> "
      p := 1
      while p <= *alpha do {
         txt := txt || " " || alpha[p].getResult()
         p +:= 1
      }      
      txt := txt || "."
      g := 1
      while g <= *beta do {
         element := beta[g]
         if \element then txt := txt || element.getResult() || " "
         g +:= 1
      }
      txt := txt || "\n"
      label := txt
   end
   
   method getTxt()
      return label
   end
   
initially()
   label := ""
   alpha := []
   beta := []
end
