#  John Goettsche
#  under the direction of Clinton Jeffery
#  University of Idaho

package states
import rawGrammar
import production

procedure createStates(args, nonTerminalsSet, TerminalsSet)
#  is a work in progress
#  creates the states for compiling the grammar for this tool

   local 
      statesList, 
      thisNonTerminal, 
      myState, 
      thisProductionRule, 
      myStateGrammar, 
      B,
      nextProductionRule,
      mySubGrammar,
      state,
      stateNumbnier,
      grammarList,
      outfile,
      thisResult

   write("N: " || *nonTerminalsSet || "\tT: " || *TerminalsSet)
   stateNumber := 0
   statesList := []
   nonTerminalList := set()
   
   #make item 0
   thisNonTerminal := nonTerminalsSet[1]
   stateName := "I" || stateNumber
   thisResult := thisNonTerminal.getResult() || "'"
   
   thisPrime := rawGrammar::Terminal(2)
   thisPrime.setResult(thisResult)
   initialGrammar := StateGrammar()
   #write("+++" || thisNonTerminal.getResult())
   initialGrammar.addBeta(thisNonTerminal)
   myState := State(stateName, thisPrime, initialGrammar) #create new state
   
   every thisStateGrammar := myState.getStateGrammars() do {
      B := thisStateGrammar.getBeta(1)
      if B.getType() == "1" then {
         if not member(nonTerminalList, B) then {
            makeStateGrammars(myState, B, nonTerminalList)
            insert(nonTerminalList, B)
         }
      }
   }
   #write("Adding first State")
   put(statesList, myState)
   
   makeAllStates(statesList, myState)
   
   if *args > 0 then if member(args, "s") then {
      outfile := &output
      if member(args, "o") then outfile := open("y-states.txt", "c")
      write("\nStates: " || *statesList || "\n") 
      if outfile ~=== &output then every state := !statesList do write(outfile, state.getTxt())
      every state := !statesList do write(state.getTxt())
      write("\n(press ENTER to continue)\n")
      getch()
   }   
end
   
procedure makeStateGrammars(myState, B, nonTerminalList)
# Makes StateGrammars for myState given a Non-Terminal (B)

   local
      mySubGrammar,
      newProductionRule,
      newVariable,
      stateNumber,
      stateName   
    
   every thisProductionRule := B.getProductionRules() do {
      newGrammar := StateGrammar()
      newGrammar.setLeft(B)
      every newB := thisProductionRule.getVariables() do{
         newGrammar.addBeta(newB)
      }
      if not duplicateGrammar(myState.getStateGrammarsList(), newGrammar) then {
         myState.addStateGrammar(newGrammar)
      }
   }
   
   every thisProductionRule := B.getProductionRules() do {
      newB := thisProductionRule.getVariable(1)
      if newB.getType() == "1" then {
         if not member(nonTerminalList, newB) then {
            insert(nonTerminalList, newB)
            makeStateGrammars(myState, newB, nonTerminalList)
         }
      }
   }
end

procedure makeAllStates(statesList, state)
   local 
      stateNumber, 
      thisState,
      newState,
      thisResult,
      newStateGrammar,
      grammarList,
      shifts,
      count
   
   stateNumber := 0   
   count := 1
   while stateNumber = 0 | count < stateNumber do {
      write(count - 1 || " / I" || stateNumber)
      if stateNumber = 0 then thisState := state
      if stateNumber > 0 then thisState := statesList[count]
      count +:= 1   
      shifts := []
      every thisStateGrammar := thisState.getStateGrammars() do {
         newStateGrammar := thisStateGrammar.getShift()
         shiftElement := newStateGrammar.getLastAlpha()
         put(shifts, shiftElement)
         element := newStateGrammar.getLeft()
         if element.getType() = "1" | "2" then {
            if not member(shifts, element) then {
               grammarList := []
               stateNumber +:= 1
               stateName := "I" || stateNumber
               newState := State(stateName, element, newStateGrammar)
               makeStateGrammarRules(thisState, newState, grammarList, shiftElement)
               if duplicateState(statesList, newState) then {
                  stateNumber -:= 1
               } else {
               if not duplicateState(statesList, newState) then {
                  put(statesList, newState)
               }
            }
         }
      }
   }
end

procedure makeStateGrammarRules(oldState, thisState, grammarList, shiftElement)
   local 
      newGrammar,
      thisGrammar,
      nonTerminalList
      
   nonTerminalList := set()
   every thisGrammar := oldState.getStateGrammars() do {
      newGrammar := thisGrammar.getShift()
      if \newGrammar then {
         if newGrammar.getLeft().getType() = "1" then {
            if newGrammar.getLeft() === shiftElement then {
               if not duplicateGrammar(thisState.getStateGrammarsList(), newGrammar) then {
                  thisState.addStateGrammar(newGrammar)
               }
            }
         }
         B := newGrammar.getBeta(1)
         if \B then if B.getType() = "1" then
            makeStateGrammars(thisState, B, nonTerminalList)
      }
   }
end

procedure duplicateGrammar(grammarList, grammar)
#  checks to see if grammar is in the grammarList, if it is
#  the grammar is suspended

   local thisGrammar
   every thisGrammar := !grammarList do {
      if thisGrammar.getTxt() == grammar.getTxt() then {
         suspend grammar
      }
   }
end

procedure duplicateState(statesList, state)
#  Checks to see if the state is a duplicate by checking
#  the first production //// in the state with the first
#  //// of all the states in the stateList

   local 
      thisState,
      thisGrammar
      
   stateGrammars := state.getStateGrammarsList()
   stateGrammar := stateGrammars[1]
   every testState := !statesList do {
      testGrammars := testState.getStateGrammarsList()
      testGrammar := testGrammars[1]  
      if testGrammar.getTxt() == stateGrammar.getTxt() then return state
   }
end

class State(name, stateGrammars)
#  this class defines a state for compiling the grammar

   method setName(newName)
      name := newName
   end

   method addStateGrammar(stateGrammarProduction)
      put(stateGrammars, stateGrammarProduction)
   end
   
   method addAlpha(newAlpha, grammarNumber)
      stateGrammars[grammarNumber].addAlpha(newAlpha)
   end

   method getName()
      return name
   end

   method getStateGrammars()
      local stateGrammarProduction
      every stateGrammarProduction := !stateGrammars do suspend stateGrammarProduction
   end

   method getStateGrammarsList()
      return stateGrammars
   end

   method getTxt()
      local txt, line
      txt := name || "\n"
      every line := !stateGrammars do txt := txt || line.getTxt()
      return txt
   end

initially(newName, thisPrime, initialGrammar)
   local 
      result,
      #accept, 
      element

   #write(thisNonTerminal.getResult())
   name := newName
   stateGrammars := []
   newStateGrammar := StateGrammar()
   newStateGrammar.setLeft(thisPrime)
   every newAlpha := initialGrammar.getAlpha() do {
      #write("!!!" || newAlpha.getResult())
      newStateGrammar.addAlpha(newAlpha)
   }
   every element := initialGrammar.getBetas() do
      newStateGrammar.addBeta(element)
   put(stateGrammars, newStateGrammar)
   #write("\t******\t" || name || "\n\t\t" || newStateGrammar.getTxt())
end

class StateGrammar(left, alpha, beta)
#  this class defines a a grammar process for the current state

   method setLeft(newLeft)
      #write(newLeft.getResult())
      left := newLeft
   end
   
   method addAlpha(newAlpha)
   #write("adding: " || newAlpha.getResult())
      put(alpha, newAlpha)
   end
   
   method addBeta(newBeta)
     # write(newGrammarElement.getTxt())
         put(beta, newBeta)
   end
   
   method setBetaList(newBetaList)
      beta := newBetaList
   end
   
   method getLeft()
      return left
   end
   
   method getAlpha()
      local element
      every element := !alpha do suspend element
   end
   
   method getAlphaList()
      return alpha
   end
   
   method getLastAlpha()
      local element, thisElement
      #write("getting shift")
      #write("+ " || *getAlphaList())
      every thisElement := getAlpha() do {
         #write("+" || thisElement.getResult())
         element := thisElement
      }
      #write(element.getResult())
      return element
   end
   
   method getBetas()
      local thisBeta
      every thisBeta := !beta do suspend thisBeta
   end
   
   method getBetaList()
      return beta
   end
   
   method getBeta(v)
      return beta[v]
   end
   
   method getShift()
      local newStateGrammar, element, count
      
      if *beta > 0 then {
         newStateGrammar := StateGrammar()
         newStateGrammar.setLeft(left)
         every element := getAlpha() do newStateGrammar.addAlpha(element)
         count := 1
         every element := getBetas() do {
            if count = 1 then {
               newStateGrammar.addAlpha(element)
            }   
            if count > 1 then {
               newStateGrammar.addBeta(element)
            }
            count +:= 1
         }
         return newStateGrammar
      }   
   end
   
   method getTxt()
      local txt, p, g, element
      txt := "\t" || left.getResult() || " -> "
      p := 1
      while p <= *alpha do {
         txt := txt || " " || alpha[p].getResult()
         p +:= 1
      }      
      txt := txt || "."
      g := 1
      while g <= *beta do {
         element := beta[g]
         if \element then txt := txt || element.getResult() || " "
         g +:= 1
      }
      txt := txt || "\n"
      return txt
   end
   
initially()
   alpha := []
   beta := []
end
