#  John Goettsche
#  under the direction of Clinton Jeffery
#  University of Idaho

package stateAnalysis
#  dose an analysis of the state to see how each state can be 
#  reached and what terminals are acceptable at that state.

import classes

procedure createStateAnalysis(fileName, args, statesList, terminalsList)
# performs an analysis of each state to determine how it can be
# reached and what are acceptable inputs

	write("\nChecking state sources...\n")
	determineAllSources(statesList)
	every state := !statesList do determineAcceptableInputsFromNonTerminals(state)
	
	if *args > 0 then if member(args, "S") then {
      outfile := &output
      outfileName := fileName || "-StateSources.txt"
      if member(args, "o") then outfile := open(outfileName, "c")
		write("\nState Sources:\n") 
      if outfile ~=== &output then every state := !statesList do {
			write(outfile, "\n" || state.name)
			write(outfile, "\tSources:")
			write(outfile, state.getSourceChainTxt())
			write(outfile, "\tConstructed Source State Chain:")
			write(outfile, state.getSourceStateChainTxt())
			write(outfile, "\tMost recent states:")
			write(outfile, state.getSourceTxt())
			write(outfile, "\tSource State Chains:")
			write(outfile, state.getSourceStateChainsTxt())
#			write(outfile, "\tMost recent inputs:")
#			write(outfile, state.getSourceInputTxt())
			write(outfile, state.getAcceptableTxt(terminalsList))
#			if *state.acceptable > 0 then write(outfile, makeNotAcceptable(state, terminalsList))
		}
		every state := !statesList do {
			write("\n" || state.name)
			write("\tSources:")
			write(state.getSourceChainTxt())
			write("\tConstructed Source State Chain:")
			write(state.getSourceStateChainTxt())
			write("\tMost recent states:")
			write(state.getSourceTxt())
			write("\tSource State Chains:")
			write(state.getSourceStateChainsTxt())
#			write("\tMost recent inputs:")
#			write(state.getSourceInputTxt())
			write(state.getAcceptableTxt(terminalsList))
#			if *state.acceptable > 0 then write(makeNotAcceptable(state, terminalsList))
		}
      classes::printTime()
      write("\n(press ENTER to continue)\n")
      getch()
   }
end

procedure makeNotAcceptable(state, terminalsList)
	local
		txt
		
	txt := "\t-- Not Acceptable Input --\n"
	every terminal := !terminalsList do {
		#write(terminal.result)
		if not duplicate(state.acceptable, terminal) then {
			txt := txt || "\t" || terminal.result || "\n"
		}
	}
	return txt || "\t--------------------------\n"
end

procedure determineAllSources(statesList)
# finds the possible routs to get to each state
	
	local 
		state,
		action,
		gotoState
		
	every state := !statesList do {
		#add alpha from each item to the states sourceChains
		every thisItem := !state.items do{
			if *thisItem.alpha > 0 then {
				thisAlpha := []
				every element := !thisItem.alpha do {
					put(thisAlpha, element)
				}
				if not duplicateChains(state.sourceChains, thisAlpha) then 	
					state.addSourceChain(thisAlpha)
			}
		}
	
		every action := !state.actions do {
			if action.actionType == "shift" then{
				every gotoState := !statesList do {
					if gotoState === action.goto then {
						gotoState.addSource(state)
						if not duplicate(gotoState.sourceInputs, action.sigma) then 
							gotoState.addSourceInput(action.sigma)
					}
				} 
			}
		}
	}
	every state := !statesList do {
		if *state.sources > 0 then {
			every thisSource := !state.sources do {
				thisSourceStateChain := []
				if \thisSource then {
					every thisState := !thisSource.sourceStateChain do {
						put(thisSourceStateChain, thisState)
					}
					put(thisSourceStateChain, thisSource)
					put(state.sourceStateChains, thisSourceStateChain)
				}
			}
		}
	}
	
end

procedure duplicate(sourceList, item)
	every testItem := !sourceList do {
		if testItem === item then return item
	}
end

procedure duplicateChains(chainList, chain)
	chainTxt := ""
	every element := !chain do {
		chainTxt := chainTxt || element.result
	}
	every testChain := !chainList do {
		testChainTxt := ""
		every element := !testChain do {
			testChainTxt := testChainTxt || element.result
		}
		if chainTxt == testChainTxt then return chainTxt
	}
end

procedure determineAcceptableInputsFromNonTerminals(state)
# finds all possible acceptable for the state.
	
	every action := !state.actions do {
		if action.actionType == "shift" then {
			if action.sigma.type == "terminal" then {
				if not duplicate(state.acceptable, action.sigma) then {
					state.addAcceptable(action.sigma)
				}
			}
		}
	}
	every action := !state.actions do {
		if action.actionType == "shift" then {		
			if action.sigma.type == "nonTerminal" then {
				if not duplicate(state.nonTerminalShifts, action.sigma) then {
					state.addNonTerminalShift(action.sigma)
					every productionRule := !action.sigma.productionRules do {
						if \productionRule then
							if productionRule.variables[1].type == "terminal" then {
								if not duplicate(state.acceptable, productionRule.variables[1]) then {
									state.addAcceptable(productionRule.variables[1])
								}
							}
					}
				}
			}
		}
		#I'm not shure this section will add anything...
		if action.actionType == "redude" then {
			thisItem := action.item.left
			if action.item.left.type == "terminal" then {
				if not duplicate(state.acceptable, action.item.left) then {
					state.addAcceptable(action.item.left)
				}
			}
			if action.item.left.type == "nonTerminal" then {
				if not duplicate(state.nonTerminalShifts, action.item.left) then {
					state.addNonTerminalShift(action.item.left)
					every productionRule := !action.item.left.productionRules do {
						if \productionRule then
							if productionRule.variables[1].type == "terminal" then {
								if not duplicate(state.acceptable, productionRule.variables[1]) then {
									state.addAcceptable(productionRule.variables[1])
								}
							}
					}
				}
			}
		}
	}
	
	
end
