#  John Goettsche
#  under the direction of Clinton Jeffery
#  University of Idaho

package stateAnalysis
#  dose an analysis of the state to see how each state can be 
#  reached and what terminals are acceptable at that state.

import classes

procedure createStateAnalysis(fileName, args, statesList)
# performs an analysis of each state to determine how it can be
# reached and what are acceptable inputs

	write("\nChecking state sources...\n")
	determineAllSources(statesList)
	every state := !statesList do determineAcceptableInputsFromNonTerminals(state)
	
if *args > 0 then if member(args, "S") then {
      outfile := &output
      outfileName := fileName || "-StateSources.txt"
      if member(args, "o") then outfile := open(outfileName, "c")
		write("\nState Sources:\n") 
      if outfile ~=== &output then every state := !statesList do write(outfile, state.getSourceTxt())
		every state := !statesList do {
			write("\n" || state.name)
			write(state.getSourceTxt())
			write(state.getSourceInputTxt())
			write(state.getAcceptableTxt())
		}
      classes::printTime()
      write("\n(press ENTER to continue)\n")
      getch()
   }
end

procedure determineAllSources(statesList)
# finds the possible routs to get to each state
	
	local 
		state,
		action,
		gotoState

	every state := !statesList do {
		every action := !state.actions do {
			if action.actionType == "shift" then{
				every gotoState := !statesList do {
					if gotoState === action.goto then {
						gotoState.addSource(state)
						if not duplicate(gotoState.sourceInputs, action.sigma) then 
							gotoState.addSourceInput(action.sigma)
					}
				} 
			}
		}
	}
end

procedure duplicate(sourceList, item)
	every testItem := !sourceList do {
		if testItem === item then return item
	}
end

procedure determineAcceptableInputsFromNonTerminals(state)
# finds all possible acceptable for the state.
	
	every action := !state.actions do {
		if action.actionType == "shift" then {
			if action.sigma.type == "terminal" then {
				if not duplicate(state.acceptable, action.sigma) then {
					state.addAcceptable(action.sigma)
				}
			}
		}
	}
#	every action := !state.actions do {
#		if action.actionType == "shift" then {		
#			if action.sigma.type == "nonTerminal" then {
#				if not duplicate(state.nonTerminalShifts, action.sigma) then {
#					state.addNonTerminalShift(action.sigma)
#					determineAcceptableInputsFromNonTerminals(action.goto)
#					every gotoAction := !action.goto.actions do {
#						if gotoAction.actionType == "shift" then {
#							if gotoAction.sigma.type == "terminal" then {
#								if not duplicate(state.acceptable, gotoAction.sigma) then {
#									state.addAcceptable(gotoAction.sigma)
#								}
#							}
#						}
#					}
#				}
#			}
#		}
#	}
end
