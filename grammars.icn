#  John Goettsche
#  under the direction of Clinton Jeffery
#  University of Idaho

#grammars.icn
package grammars

import classes
import productionRules

procedure createNonTerminals(fileName, args, rawGrammar)  
#  from the rawGrammar it creates the NonTerminals and
#  procedes the createTerminals procedure

   #create nonTerminals
   local 
      nonTerminal, 
      nonTerminalWords, 
      nonTerminalsSet, 
      nonTerminalCheckSet,
      nonTerminalsList,
      outfile,
      outfileName
   
	write("Creating Non-Terminals...\n")
   nonTerminalWords := []
   nonTerminalCheckSet := set()
   every nonTerminal := getNonTerminals(rawGrammar) do 
      if not member(nonTerminalCheckSet, nonTerminal) then {
         put(nonTerminalWords, nonTerminal)
         insert(nonTerminalCheckSet, nonTerminal)
      }
   #every write(!nonTerminalCheckSet)
   nonTerminalsList := []
   every put(nonTerminalsList, makeNonTerminalsSet(nonTerminalWords))

   if *args > 0 then if member(args, "n") then {
      outfile := &output
      outfileName := fileName || "-nonTerminals.txt"
      if member(args, "o") then outfile := open(outfileName, "c")
      write("\nNon Terminals\n") 
      if outfile ~=== &output then every write(outfile, !nonTerminalWords)
      every write("\t" || !nonTerminalWords)
		classes::printTime()
      write("\n(press ENTER to continue)\n")
      getch()
   }  
   createTerminals(fileName, args, rawGrammar, nonTerminalCheckSet, nonTerminalsList)
end

procedure createTerminals(fileName, args, rawGrammar, nonTerminalCheckSet, nonTerminalsSet)
#  from the rawGrammar, nonTerminalCheckSet and nonTerminalSet it
#  produces the terminals and procedes to the creaeGrammar procedure

   #create terminals
   local 
      terminalsList, 
      terminalsSet, 
      terminalCheckSet, 
      terminal,
      outfile,
      outfileName,
		terminalsWordList
      
	write("Creating Terminals...\n")
   terminalsWordList := []
   terminalCheckSet := set()
   every terminal := getTerminals(rawGrammar, nonTerminalCheckSet) do 
      if not member(terminalCheckSet, terminal) then { 
         put(terminalsWordList, terminal)
         insert(terminalCheckSet, terminal)
      }
   terminalsList := []
	every put(terminalsList, makeTerminalsList(fileName, args, terminalsWordList))

   if *args > 0 then if member(args, "t") then {
      outfile := &output
      outfileName := fileName || "-terminals.txt"
      if member(args, "o") then outfile := open(outfileName, "c")
      write("\nTerminals\n") 
      if outfile ~=== &output then every write(outfile, !terminalsWordList)
      every terminal := !terminalsList do write("\t" || terminal.token)
		classes::printTime()
      write("\n(press ENTER to continue)\n")
      getch()
   }  
	
	if *args > 0 then if member(args, "T") then {
      outfileName := fileName || ".tk"
      outfile := open(outfileName, "c")
      if outfile ~=== &output then {
         every terminal := !terminalsList do write(outfile, terminal.token || "\t\t\t#" || terminal.token)
      }
      every write("\t" || !rawGrammar)
		classes::printTime()
      stop("\nCreated " || outfileName || "\n")
   }
	
   #write(production)
   productionRules::createProductionRules(
         fileName,
         args,
         rawGrammar, 
         nonTerminalCheckSet, 
         nonTerminalsSet, 
         terminalCheckSet, 
         terminalsList)
end

procedure getNonTerminals(wordList)
#  finds and suspends all the NonTerminals in the list (rawGrammar)

   local x
   x := 1
   while wordList[x] do {
      if wordList[x] ~== "|" then suspend wordList[x]
      x +:= 1
      while wordList[x] ~== ";" do x := x + 1
      x +:= 1
   } 
end

procedure makeNonTerminalsSet(nonTerminalWords)
#  creates and suspends each NonTerminal in the nonTerminalWords
# in the order they appear in the grammar
   local 
		x, 
		token, 
		thisNonTerminal
	
   every token := !nonTerminalWords do {
      thisNonTerminal := classes::NonTerminal()
      thisNonTerminal.token := token
      suspend thisNonTerminal
   }
end

procedure makeTerminalsList(fileName, args, terminalsList)
# creates and susends each Terminal in the terminalsList
   local 
		token, 
		thisTerminal,
		pattern,
		thisPattern
	
	fileN := fileName || ".tk"
	#wordDef := &letters++&digits++'_*/%{}|:;+-$#@!&()[]<>,.~`'	
   every token := !terminalsList do {
		thisTerminal := classes::Terminal("terminal")
		thisTerminal.token := token
		if *args > 0 then if not member(args, "T") then {
			tkfile := open(fileN, "r") | stop("ERROR: trouble reading " || fileN)
			pattern := getPattern(tkfile, token)
			close(tkfile)
			thisTerminal.pattern := pattern
		}
      suspend thisTerminal
   }
	
end

procedure getPattern(tkfile, token)
	pattern := "#"
	wordDef := &letters++&digits++'_*/%{}|:;+-$#@!&()[]<>,.~`'	
	every line := !tkfile do {
		line ? while tab(upto(wordDef)) do {
			tokenString := tab(many(wordDef))
			tab(upto(wordDef))
			thisPattern := tab(many(wordDef))
			if *thisPattern < 1 then thisPattern := "#"
			if tokenString == token then {
				pattern := thisPattern
			}
		}
	}
	return pattern
end

procedure getTerminals(wordList, nonTerminalsList)
#  finds all the Terminals in the list and creates and suspends
#  each terminal

   local x
   x := 1
   while wordList[x] do {
      if not member(nonTerminalsList, wordList[x]) then {
         if not (wordList[x] == (":"|";"|"|")) then
	    suspend wordList[x]
      }
      x := x + 1
   }
end