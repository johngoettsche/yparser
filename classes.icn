#  John Goettsche
#  under the direction of Clinton Jeffery
#  University of Idaho

package classes
#  Contains the classes associated with yparser

procedure printTime()
	local 
		time,
		h,
		m,
		seconds
		
	time := &time
   h := time / 3600000
   time := time % 3600000
   m := time / 60000
   time := time % 60000
   seconds := time / 1000.0
   write("\nTime elapsed: " || h || ":" || m || ":" || seconds)
end

procedure duplicate(sourceList, item)
	every testItem := !sourceList do {
		if testItem === item then return item
	}
end

class Terminal(type, result)
#  used to hold a single terminal

   method setResult(newResult)
      result := newResult
   end

   method getType()
      return type
   end

   method getResult()
      return result
   end   

initially (thisType)
   type := thisType
end

class NonTerminal(type, result, productionRules)
#  used to hold a single non terminal

   method setResult(newResult)
      result := newResult
   end

   method addProductionRule(newProductionRule)
      put(productionRules, newProductionRule)
   end

   method getType()
      return type
   end

   method getResult()
      return result
   end

   method findRule(matchRule)
      local productionRule
      every productionRule := !productionRules do
         if productionRule == matchRule then return productionRule
   end
      
   method getProductionRule(r)
      return productionRules[r]
   end

   method getProductionRules()
      local productionRule
      every productionRule := !productionRules do suspend productionRule
   end

   method getTxt()      
      local productionRule, thisString
      every productionRule := !productionRules do {
         thisString := result || " <- " || productionRule.getTxt()
         suspend thisString
      }
   end
   
initially
   type := "nonTerminal"
   productionRules := []
end

class ProductionRule(variables)
#  used to hold all the inputs for each grammar rule
# the stuff that gets converted over into a non-terminal, a RHS.
   
   method addVariable(newVariable) 
      put(variables, newVariable)
   end

   method getVariables()
      local variable
      every variable := !variables do suspend variable
   end

   method getVariableList()
      return variables
   end
   
   method getVariable(v)
      return variables[v]
   end

   method getTxt()
      local x, str
      str := ""
      x := 1
      while x <= *variables do {
         #write(variables[x].getResult())
         str := str || variables[x].getResult() || " "
         x +:= 1
      }
      return str
   end

initially
   variables := []
end

class State(
	name, 
	items, 
	label,
	actions, 
	sources, 
	sourceChain,
	sourceChains, 
	sourceStateChain, 
	sourceStateChains, 
	sourceInputs, 
	acceptable, 
	nonTerminalShifts)
#  this class defines a state
#	name: I#
#	items:  a list of items
#	label:  the name plus the first item
#  actions:
#	sources: most recent states
#	sourceChain: the chain of inputs that bring you to this state by construction
#	sourceChains: a list of chains of inputs that bring you to this state 
#	sourceStateChain: the chain of states that brings you to this state by construction
#	sourceStateChains:  a list of possible chains that bring you to this state
#	sourceInputs: most recent input that brings you to this state
#	acceptable: list of acceptable inputs
#	nonTerminalShifts

   method setName(newName)
      name := newName
   end

   method addItem(itemProduction)
      put(items, itemProduction)
   end
   
   method addAlpha(newAlpha, ItemNumber)
      items[ItemNumber].addAlpha(newAlpha)
   end
	
	method addAction(action)
		put(actions, action)
	end
	
	method addSource(source)
		put(sources, source)
	end
	
	method addSourceToChain(newSource)
		put(sourceChain, newSource)
	end
	
	method addSourceChain(newSourceChain)
		put(sourceChains, newSourceChain)
	end
	
	method addSourceStateChain(newSourceStateChain)
		put(sourceStateChains, newSourceStateChain)
	end
	
	method addSourceInput(sourceInput)
		put(sourceInputs, sourceInput)
	end
	
	method addAcceptable(input)
		put(acceptable, input)
	end
	
	method addNonTerminalShift(nonTerminal)
		put(nonTerminalShifts, nonTerminal)
	end
	
   method getName()
      return name
   end

   method getItems()
      local itemProduction
      every itemProduction := !items do suspend itemProduction
   end

   method getItemsList()
      return items
   end
	
	method getStateChains()
		every stateChain := !sourceStateChains do suspend stateChain
	end

   method setTxt()
      local txt, line
      txt := name || "\n"
      every line := !items do txt := txt || line.label
      label := txt
   end
	
	method getActionTxt()
		local txt, line
		txt := ""
		every line := !actions do txt := txt || line.label
		
		return txt
	end

	method getSourceChainTxt()
		local txt, thisSource
		txt := "\t\t"
		every thisSource := !sourceChain do {
			txt := txt || thisSource.result || " "
		}
		txt := txt || "\n"
		return txt
	end

	method getSourceChainsTxt()
		local txt, thisItem, element
		
		txt := ""
		every thisSourceChain := !sourceChains do{
			txt := txt || "\t\t"
			every element := !thisSourceChain do {
				txt := txt || element.result || " "
			}
			txt := txt || "\n"
		}
		return txt
	end
	
	method getSourceStateChainTxt()
		local txt, thisItem, element
		
		if *sourceStateChain > 0 then {
			txt := "\t\t"
			every thisState := !sourceStateChain do {
				if \thisState then txt := txt || thisState.name || " "
			}
			txt := txt || "\n"

			return txt
		}
	end
	
	method getSourceStateChainsTxt()
		local txt, thisItem, element
		
		if *sourceStateChains > 0 then {
			txt := ""
			every thisSourceStateChain := !sourceStateChains do{
				txt := txt || "\t\t"
				if *thisSourceStateChain > 0 then
					every thisState := !thisSourceStateChain do {
						if \thisState then txt := txt || thisState.name || " "
					}
				txt := txt || "\n"
			}
			return txt
		}
	end
	
	method getSourcesTxt()
		local txt, source, count
		count := 0
		txt := "\t\t{"
		every source := !sources do {
			if count > 0 then txt := txt || ", "
			txt := txt || source.name
			count +:= 1
		}
		txt := txt || "}\n"
		return txt
	end
	
	method getSourceInputTxt()
		local txt, source, count
		count := 0
		txt := "\t\t["
		every sourceInput := !sourceInputs do {
			if count > 0 then txt := txt || ", "
			txt := txt || sourceInput.result
			count +:= 1
		}
		txt := txt || "]\n"
		return txt
	end
	
	method getAcceptableTxt(terminalList)
		local txt
		
		if *acceptable > 0 then {
			txt := "\t---- Acceptable Input ----\n"
			every acceptableInput := !acceptable do txt := txt || "\t" || acceptableInput.result ||"\n"
			return txt  || "\t--------------------------\n"
		}
	end

initially(newName, thisPrime, initialItem, thisStateChain, sourceState)
   local 
      result,
      element,
      newItem,
      newAlpha
   
   label :=""
   name := newName
   items := []
	actions := []
	sources := []
	sourceChain := []
	sourceChains := []
	sourceStateChain := []
	sourceStateChains := []
	sourceInputs := []
	acceptable := []
	nonTerminalShifts := []
   
	#source states
	if *thisStateChain > 0 then {
		every thisState := !thisStateChain do {
			put(sourceStateChain, thisState)
		}
	}
	
	if \sourceState then { 
		put(sourceStateChain, sourceState)
	}
	
   #set up initialItem
   newItem := Item()
   newItem.setLeft(thisPrime)
   every newAlpha := initialItem.getAlpha() do {
      newItem.addAlpha(newAlpha)
   }
   every element := initialItem.getBetas() do
      newItem.addBeta(element)
   newItem.setTxt()
   put(items, newItem)
   setTxt()
end

class Item(left, alpha, beta, label)
#  this class defines an Item for a state

   method setLeft(newLeft)
      left := newLeft
   end
   
   method addAlpha(newAlpha)
      put(alpha, newAlpha)
   end
   
   method addBeta(newBeta)
         put(beta, newBeta)
   end
   
   method setBetaList(newBetaList)
      beta := newBetaList
   end
   
   method getLeft()
      return left
   end
   
   method getAlpha()
      local element
      every element := !alpha do suspend element
   end
   
   method getAlphaList()
      return alpha
   end
   
   method getLastAlpha()
      local element, thisElement
      every thisElement := getAlpha() do {
         element := thisElement
      }
      return element
   end
   
   method getBetas()
      local thisBeta
      every thisBeta := !beta do suspend thisBeta
   end
   
   method getBetaList()
      return beta
   end
   
   method getBeta(v)
      return beta[v]
   end
   
   method getShift()
      local 
         newItem, 
         element, 
         count
      
      if *beta > 0 then {
         newItem := Item()
         newItem.setLeft(left)
         every element := getAlpha() do newItem.addAlpha(element)
         count := 1
         every element := getBetas() do {
            if count = 1 then {
               newItem.addAlpha(element)
            }   
            if count > 1 then {
               newItem.addBeta(element)
            }
            count +:= 1
         }
         newItem.setTxt()
         return newItem
      }   
   end
   
   method setTxt()
   #prepares the textual representation of the Item
      local 
         p, 
         g, 
         element,
         txt
         
      txt := "\t" || left.getResult() || " -> "
      p := 1
      while p <= *alpha do {
         txt := txt || " " || alpha[p].getResult()
         p +:= 1
      }      
      txt := txt || "."
      g := 1
      while g <= *beta do {
         element := beta[g]
         if \element then txt := txt || element.getResult() || " "
         g +:= 1
      }
      txt := txt || "\n"
      label := txt
   end
   
initially()
   label := ""
   alpha := []
   beta := []
end

class Action(actionType, state, item, sigma, label, goto)
	method getLabel()
		return label
	end

initially(newState, newItem, newType, newSigma, newGoto)
# creates transitions based upon algorithm 4.8 on page 227
# of the Dragon Book
	state := newState
	item := newItem
	goto := newGoto
	actionType := newType
	sigma := newSigma
	if actionType == "accept" then label := "\t" || actionType || "\n"
	else if actionType == "shift" then label := "\tgoto(" || state.name || ", " || sigma.getResult() || ") = " || goto.name || "\n"
	else if actionType == "reduce" then label := "\t" || actionType || item.label
	else actionType := "error"
end
